# sfti 编译器简介

+ 使用递归下降子程序法
+ 处理c0文法
+ 生成pcode
+ 其他若干特征

## 运行方法
编译器
指令 
```make``` 
生成sfti.exe 
```sfti.exe 1.c``` 生成对应的pcode

模拟器
指令
```make simulator``` 
处理对应的pcode
```simulator.exe pcode```

## 编译器架构
主要分成这三部分，采用中间树表示是因为这样可以简化方便优化，并且原则上需要有一个中间表示
因为有中间表示可以方便生成针对其他原型机的代码(不只是pl0机)

+ 词法分析部分
+ 中间树表示生成
+ pcode生成

## 词法分析部分
词法分析部分在
```词法分析程序实验报告``` 已经提过，不再赘述

## 中间树表示
采用自己的中间树表示，并且在中间树表示这里处理所有的错误，如果有语法等的错误，将在这一层级报错。
### 错误处理
见后表
### 符号表
参考了现代编译器原理一书的实现，使用栈式哈希链表(~~我自己起的~~)的数据结构完成，O1的访问时间内完成变量的存取。

## pcode生成

## 其他语法特性
### 支持string 类型
### 支持float 类



##  关于pcode 的若干问题
使用教材 pxx 的pcode 并不能完全表示c0语法的特征，所以我针对指令集进行了一点~~微小~~的**修改**
并且对运行模型进行了一定程度的修改，下面就我使用的指令给与说明。

b 栈基址
t 栈顶指针1
S 栈区
ip 当前指令指针
LIT  x,y  将常数y置于栈顶,并t=t+1
LOD  x,y  将层次差x,offset 为y的变量载入栈顶 t=t+1
STO  x,y  将栈顶的值存入层次差x,offset为y 的变量中 t=t-1
MKS  x,y  栈标记指令, y是新栈帧中分配给参数的空间量 完成的动作如下
	S(t+1)=b  //动态连设置
	S(t+2)=b  //静态链的暂时设置
	b=t
	t=t+4+y   //分配相应的参数和栈帧空间
CAL  x,y 调用指令，层次差x,起始地址y
	S(b+3)=ip+1
	S(b+2)=SL
	SL 的获取方式是不断沿着静态链上x次 寻直到找到调用的函数
	ip=y
INT  x,y  将栈顶增加y
	t=t+y
JMP  x,y  无条件跳转
	ip=y
JPC  x,y  有条件跳转
	t=t-1
	if S(t-1) == 0 ip = y
RED  x,y  等待输入，并将输入填入层次差为x offset 为y 的变量
WRT  x,y  输出栈顶数字 t=t-1
WRTS x,y  输出栈顶的字符 t=t-1
FLT  x,y  浮点数转换
	if y==1 将栈顶浮点转换为整形
	if y==0 将栈顶整形转换为浮点
OPR  x,y  根据y执行不同的运算操作，如下
	 case y==0 :
	 	执行返回指令，将栈顶元素作为返回值返回
	 	S(b)=S(t-1)
	 	t=b+1
	 	ip=S(b+3)
	 	b=S(b+1)
	 case y==2 :
	 	执行add 操作 
	 	S(t-2)=S(t-2)+S(t-1)
	 	t=t-1
	 case y==3 :
	 	执行minus操作
	 	S(t-2)=S(t-2)-S(t-1)
	 	t=t-1
	 case y==4 :
	 	执行乘法操作
	 	S(t-2)=S(t-2)*S(t-1)
	 	t=t-1
	 case y==5 :
	 	执行除法操作
	 	S(t-2)=S(t-2)/S(t-1)
	 	t=t-1
	 case y==8 :
	 	等于 同下
	 case y==9 :
	 	不等于
	 	if S(t-2)==S(t-1)
	 		S(t-2)=0
	 	else 
	 		S(t-2)=1
	 case y==10: 
	  	小于
	  	ifS(t-2) < S(t-1)
	  	 	S(t-2)=1
	  	 else 
	  	 	S(t-1)=0
	 case y=11 
	 	大于 同上
	 case y=12
	 	大于等于
	 case y=13
	 	小于等于

## 修改后的运行时模型
因为pl0树上的pcode是不够的，并且模型也不够表示，所以这里对活动记录，栈帧表示进行了些许修改。

修改后的活动记录，每一个栈帧自下而上分别是 返回值，动态链，静态链， 返回地址
![AR](https://raw.githubusercontent.com/sfzyk/buaa-c0compiler/master/fig/ar.png)

因为要进行函数参数传递的缘故，参考后面的pascal-s 添加了mks 指令，用在cal指令前设置一个栈帧，其中就包括了参数的分配


